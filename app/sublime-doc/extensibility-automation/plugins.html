<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8">
	<title>插件</title>
	<link rel="stylesheet" href="../main.css">
</head>
<body>
	<h1>插件(Plugins)</h1>
	<div class="quote">
		<h3>参见</h3>
		<dl>
			<dt><a href="">API参考</a></dt>
			<dd>更多关于Python API的信息</dd>
		</dl>
		<dl>
			<dt><a href="">插件参考</a></dt>
			<dd>更多关于插件的信息</dd>
		</dl>
	</div>
	<p>这一节为有编程技能的用户准备。</p>
	<p>可以通过Python插件来扩展ST。插件通过重用已有的命令或者创建新的命令来建立特性。插件是一个逻辑实体，而不是物理实体。</p>
	<h2>预备知识</h2>
	<p>要编写插件，你必须能够使用<a href="http://www.python.org/">Python</a>编程。在撰写本文时，ST使用Python 3。</p>
	<h2>在哪存储插件</h2>
	<p>ST只会从这些位置寻找插件：</p>
	<ul>
		<li><code>Installed Packages</code>(只是.sublime-package文件)</li>
		<li><code>Packages</code></li>
		<li><code>Packages/&lt;pkg_name&gl;/</code></li>
	</ul>
	<p>因此，任何在<code>Packages</code>中深入嵌套的插件都不会被加载。</p>
	<p>不鼓励直接将插件放在<code>Packges</code>下。ST会在加载插件之前使用预定义的方式对其进行排序，所以如果你直接将插件文件保存在<code>Packages</code>下，你可能会得到混乱的结果。</p>
	<h2>你的第一个插件</h2>
	<p>让我们为ST编写一个“Hello,World!”插件：</p>
	<ol>
		<li>在菜单中选择<span class="menu">Tools|New Plugin...</span>。</li>
		<li>保存到<code>Packages/User/hello_world.py</code>。</li>
	</ol>
	<p>你刚刚已经编写了你的第一个插件！让我们来使用它：</p>
	<ol>
		<li>创建一个新的缓冲区(<code>Ctrl+n</code>)。</li>
		<li>打开Python控制台(Ctrl+`)。</li>
		<li>输入<code>view.run_command("example")</code>然后按回车。</li>
	</ol>
	<p>你应当在新创建的缓冲区中看到文本“Hello,World!”。</p>
	<h2>分析你的第一个插件</h2>
	<p>在前一节创建的插件粗糙地看起来应当像这样：</p>
	<div class="snippet">
		<pre>
			import sublime, sublime_plugin

			class ExampleCommand(sublime_plugin.TextCommand):
			    def run(self, edit):
			        self.view.insert(edit, 0, "Hello, World!")
		</pre>
	</div>
	<p><code>sublime</code>和<code>sublime_plugin</code>模板都是由ST提供的；它们不是Python标准库的一部分。</p>
	<p>像我们前面提到的，插件重用或者创建命令。在ST中命令是基本构建块。它们仅仅是Python类，可以以相似的方式从不同的ST工具被调用，这些工具包括插件API，菜单文件，宏，等等。</p>
	<p>ST命令来自在<code>sublime_plugin</code>中定义的<code>*command</code>类(后面有更多相关内容)。</p>
	<p>我们示例中的剩余代码涉及<code>TextCommand</code>或者API。我们会在后面的章节中讨论这些主题。</p>
	<p>不过，在继续之前，我们会看一下我们怎样调用新命令：首先我们打开Py控制台然后我们发出一个到<code>view.run_command()</code>的调用。这是一个相当不方便的调用命令的方式，但是在一个插件的开发阶段它通常是有用的。目前，记住你的命令可以通过键绑定以及其它方法被访问，就像其它命令。</p>
	<h3>命令名称的约定</h3>
	<p>你可能已经注意到我们命令被命名为<code>ExampleCommand</code>,但是我们却将字符串<code>example</code>传递给API调用。这是必须的，因为ST通过去除<code>Command</code>后缀以及使用下划线分隔<code>PhraseLikeThis</code>(像这样：<code>Phrase_Like_This</code>)来标准化命令名称。</p>
	<p>新命令应当遵循同样的命名模式。</p>
	<h2>命令类型</h2>
	<p>你可以创建下列命令类型</p>
	<ol>
		<li>窗口命令(<code>sublime_plugin.WindowCommand</code>)</li>
		<li>文本命令(<code>sublime_plugin.TextCommand</code>)</li>
	</ol>
	<p>当编写插件时，考虑你的目标然后选择合适的命令类型。</p>
	<h3>命令的共享特性</h3>
	<p>为了能工作所有的命令都需要实现<code>.run()</code>方法。此外，它们可以接受任意长度数量的关键字参数。</p>
	<p><strong>注意：</strong>由于ST在内部序列化它们的方式，命令的参数必须是有效的JSON值。</p>
	<h3>窗口命令</h3>
	<p>窗口命令在窗口级别起作用。这不是意味着你不能从窗口命令操纵视图，而是你不需要视图来启用窗口命令。例如，内建的命令<code>new_file</code>是作为<code>WindowCommand</code>定义的，所以女即使没有打开的视图它也会生效。在那种情况下需要一个视图存在是没有意义的。</p>
	<p>窗口命令实例有一个<code>.window</code>属性来指向创建他们的窗口实例。</p>
	<p>窗口命令的<code>.run()</code>方法不需要任何定位参数。</p>
	<p>窗口命令能够引导文本命令到窗口的活动视图。</p>
	<h3>文本命令</h3>
	<p>文本命令在视图级别起作用，所以它们需要视图的存在以启用。</p>
	<p>文本命令实例有一个<code>.view</code>属性指向创建它们的视图实例。</p>
	<p>文本命令的<code>.run()</code>方法需要一个<code>edit</code>实例来作为它的第一个定位参数。</p>
	<h3>文本命令和<code class="boldcode">edit</code>对象</h3>
	<p>edit对象聚合对视图的修改因此撤销和宏能明智的工作。</p>
	<p><strong>注意：</strong>与老版本相反，ST 3不允许对edit对象编程式的控制。API负责管理它们的生命周期。插件创建者必须确保新文本命令所有的修改操作发生在<code>.run()</code>方法内。要调用已有的命令，你可以使用<code>view.run_command(&lt;cmd_name&gt;, &lt;args&gt;)</code>或者类似的API调用。</p>
	<h3>事件的响应</h3>
	<p>任何源自<code>EventListener</code>的命令都将能够响应事件。</p>
	<h3>另一个插件示例：输送Cmopletion列表</h3>
	<p>让我们创建一个插件，它从谷歌的Autocomplete服务抓取数据然后将数据输送给ST的Completion列表。请注意，作为插件的一个想法，这是非常糟糕的。</p>
	<div class="snippet">
		<pre>
			import sublime, sublime_plugin

			from xml.etree import ElementTree as ET
			import urllib

			GOOGLE_AC = r"http://google.com/complete/search?output=toolbar&q=%s"

			class GoogleAutocomplete(sublime_plugin.EventListener):
			    def on_query_completions(self, view, prefix, locations):
			        elements = ET.parse(
			            urllib.request.urlopen(GOOGLE_AC % prefix)
			        ).getroot().findall("./CompleteSuggestion/suggestion")

			        sugs = [(x.attrib["data"],) * 2 for x in elements]

			        return sugs
		</pre>
	</div>
	<div class="quote">
		<h3>注意</h3>
		<p>在尝试之后，确保你不会保留这个插件或者它会介入自动完成系统。</p>
	</div>
	<div class="quote">
		<h3>参见</h3>
		<dl>
			<dt><a href="">EventListener.on_query_completions()</a></dt>
			<dd>有关示例中使用的API事件的文档。</dd>
		</dl>
	</div>
	<h2>学习API</h2>
	<p>为了创建插件，你需要熟悉ST API和可用的命令。在文本写作时这两方面的文档都是缺乏的，但是你可以阅读现有的代码并从中学习。</p>
	<p>尤其是<code>Packages/Default</code>包含许多没有文档的命令和API调用的示例。要注意的是你将不得不首先解压它的内容到一个文件夹中，如果你想要看其中的代码的话。作为练习，你可以尝试创建一个构建系统来即时完成它，并且创建一个项目文件以能够方便地浏览示例。</p>
</body>
</html>